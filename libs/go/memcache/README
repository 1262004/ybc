Fast client and server implementations for memcache protocol.

The package contains the following client implementations:
  * Client - talks to a single memcache server.
  * DistributedClient - routes requests to multiple servers using consistent
    hashing. Supports addition/removal of servers on the fly.
  * CachingClient - saves network bandwidth between the client and servers
    by storing responses in local cache. Can talk only to servers supporting
    'conditional get' (cget) memcache extension.

Server implementation has the following features:
  * 'conditional get' (cget) memcache extension.
  * 'dogpile effect-aware get' (getde) memcache extension.

================================================================================
How to build and use it?

$ go get -u github.com/valyala/ybc/libs/go/memcache

Then import it into your program:

import "github.com/valyala/ybc/libs/go/memcache"

Documentation can be generated by:

$ go doc github.com/valyala/ybc/libs/go/memcache

or read at http://go.pkgdoc.org/github.com/valyala/ybc/libs/go/memcache .

================================================================================
FAQ

Q: Why didn't you implement 'replace', 'append', 'prepend', 'incr', 'decr'
   and 'touch' memcache commands?
A: Because I think they are useless for caching purposes.

Q: Your benchmarks show CachingClient is slower than simple Client. Then what's
   the purpose of CachingClient?
A: CachingClient saves network bandwidth between memcache servers
   and the client. It won't help much if memcache servers are located
   on the same machine as the client itself. But it can save a lot of bandwidth
   if you cache items with sizes exceeding ~100 bytes on memcache servers
   accessed over the network.
   CachingClient may also deliver much higher qps comparing to simple Client
   if CachingClient.SetWithValidateTtl*() functions are used intelligently
   with validateTtl values higher than 0.
