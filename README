YBC - Yet another Blob Cache library.

This library provides support for in-process blob cache.

===============================================================================

YBC features.

* Huge amounts of data can be cached.
  + Key and value sizes are limited by 2^64 bytes on 64-bit platforms.
  + The maximum number of items in the cache is 2^64 on 64-bit platforms.
  + The maximum size of cached data is limited by 2^64 bytes on 64-bit
    platforms. In practice it is limited by free space on backing store.
    So millions multi-GB media files can be easily placed into the cache
    if backing store can handle such amount of data.
  32-bit platforms have much smaller limits (2^32), so try avoiding them
  even if the code supports 32-bit builds.

* Multithreading support. The library is thread-safe out of the box
  unless it is compiled with YBC_SINGLE_THREADED macro defined.

* Atomic updates. It is safe updating an item while other threads are reading
  an old value for an item under the same key.

* 'Add transaction' support, which allows constructing item's value on the fly
  without serializing it into a temporary buffer before its' addition into
  the cache. Uncommited transaction can be rolled back at any time.
  Think of media files streamed from the backend or complex objects, which
  require serialization from multiple distinct places before storing into
  the cache.

* Readers and writers don't block each other while reading/writing blobs
  from/into the cache. The speed is actually limited by hardware memory
  bandwidth (if frequently accessed items fit RAM) or backing store
  I/O bandwidth (if requently accessed items don't fit RAM).

* Dogpile effect (aka 'thundering herd') handling support.

* Cache data may be sharded among available backing store devices.
  Such sharding may linearly increase cache performance if frequently accessed
  items don't fit available physical RAM.

* Automatic robust recovery from corrupted index files. Corruptions in data
  files may be left unnoticed due to performance reasons - it may be very
  expensive validating multi-GB blobs on every access.

* Data file structure is optimized for HDD and SSD devices. The code
  prefers sequential I/O instead of random I/O.

* Optimization for multi-tiered memory hierarchy in modern CPUs. The code avoids
  unnecessary memory accesses and tightly packs frequently accessed data
  in order to reduce working set size.

* Persistence support. Cache data survives process restart if the cache
  is explicitly backed by files.

* Instant invalidation of all items in the cache irregardless of cache size.

* The code avoids using dynamic memory allocations as much as possible,
  so cache performance is almost independent of the efficiency of the provided
  malloc() implementation.

* The code depends only on OS-supplied libraries.

* The code can be easily ported to new platforms. All platform-specific
  functions and types are hidden behind platform-independent wrappers.

* Public interface (ybc.h) is designed with future versions' compatibility
  in mind. It doesn't expose private structures' contents, so they can be freely
  modified in the future versions of the library without breaking applications
  dynamically linked against older versions.


===============================================================================

Use-cases.

* CDN cache.

* File hosting cache.

* Memcache-like cache.

* Web-proxy or web-accelerator cache.

* Web-browser cache.

* Out-of-gc cache for garbage-collected languages.
